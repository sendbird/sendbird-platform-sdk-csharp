/*
 * Sendbird Platform SDK
 *
 * Sendbird Platform API SDK  https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@sendbird.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = sendbird_platform_sdk.Client.OpenAPIDateConverter;

namespace sendbird_platform_sdk.Model
{
    /// <summary>
    /// OcCreateChannelData
    /// </summary>
    [DataContract]
    public partial class OcCreateChannelData :  IEquatable<OcCreateChannelData>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OcCreateChannelData" /> class.
        /// </summary>
        /// <param name="name">Specifies the channel topic, or the name of the channel. The length is limited to 191 characters. (Default: open channel).</param>
        /// <param name="channelUrl">Specifies the URL of the channel. Only numbers, characters, and underscores are allowed. The length is 4 to 100 characters, inclusive. If not specified, a URL is automatically generated..</param>
        /// <param name="coverUrl">Specifies the URL of the cover image. The length is limited to 2,048 characters..</param>
        /// <param name="coverFile">Uploads a file for the channel cover image..</param>
        /// <param name="customType">Specifies the custom channel type which is used for channel grouping. The length is limited to 128 characters.&lt;br /&gt;&lt;br /&gt; Custom types are also used within Sendbird&#39;s [Advanced analytics](/docs/chat/v3/platform-api/guides/advanced-analytics) to segment metrics, which enables the sub-classification of data views..</param>
        /// <param name="data">Specifies additional channel information such as a long description of the channel or &#x60;JSON&#x60; formatted string..</param>
        /// <param name="isEphemeral">Determines whether to preserve the messages in the channel for the purpose of retrieving chat history or not. It set to true, the messages in the channel are not saved in the Sendbird database and the chat history can&#39;t be retrieved. (Default: false).</param>
        /// <param name="isDynamicPartitioned2HowDynamicPartitioningWorks">Determines whether the channel is an open channel with dynamic partitioning or not. If the value of this property is true, the open channel can create several subchannels in order to accommodate a massive number of usres. (Default: false)&lt;br/&gt;&lt;br/&gt;  For the new Sendbird applications created after December 15, 2020, this property will be automatically set to true..</param>
        /// <param name="operatorIds">Specifies an array of one or more user IDs to register as operators of the channel. The maximum allowed number of operators per channel is 100. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.&lt;br/&gt;&lt;br/&gt;  Operators cannot view messages that have been [moderated by](/docs/chat/v3/platform-api/guides/filter-and-moderation) the domain filter or profanity filter. Only the sender will be notified that the message has been blocked..</param>
        /// <param name="operators">(Deprecated) Specifies the string IDs of the users registered as channel operators. Operators can delete any messages in the channel, and can also receive all messages that have been throttled..</param>
        public OcCreateChannelData(string name = default, string channelUrl = default, string coverUrl = default, System.IO.Stream coverFile = default(System.IO.Stream), string customType = default, string data = default, bool isEphemeral = default(bool), bool isDynamicPartitioned2HowDynamicPartitioningWorks = default(bool), List<string> operatorIds = default, List<string> operators = default)
        {
            this.Name = name;
            this.ChannelUrl = channelUrl;
            this.CoverUrl = coverUrl;
            this.CoverFile = coverFile;
            this.CustomType = customType;
            this.Data = data;
            this.IsEphemeral = isEphemeral;
            this.IsDynamicPartitioned2HowDynamicPartitioningWorks = isDynamicPartitioned2HowDynamicPartitioningWorks;
            this.OperatorIds = operatorIds;
            this.Operators = operators;
        }

        /// <summary>
        /// Specifies the channel topic, or the name of the channel. The length is limited to 191 characters. (Default: open channel)
        /// </summary>
        /// <value>Specifies the channel topic, or the name of the channel. The length is limited to 191 characters. (Default: open channel)</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// Specifies the URL of the channel. Only numbers, characters, and underscores are allowed. The length is 4 to 100 characters, inclusive. If not specified, a URL is automatically generated.
        /// </summary>
        /// <value>Specifies the URL of the channel. Only numbers, characters, and underscores are allowed. The length is 4 to 100 characters, inclusive. If not specified, a URL is automatically generated.</value>
        [DataMember(Name="channel_url", EmitDefaultValue=false)]
        public string ChannelUrl { get; set; }

        /// <summary>
        /// Specifies the URL of the cover image. The length is limited to 2,048 characters.
        /// </summary>
        /// <value>Specifies the URL of the cover image. The length is limited to 2,048 characters.</value>
        [DataMember(Name="cover_url", EmitDefaultValue=false)]
        public string CoverUrl { get; set; }

        /// <summary>
        /// Uploads a file for the channel cover image.
        /// </summary>
        /// <value>Uploads a file for the channel cover image.</value>
        [DataMember(Name="cover_file", EmitDefaultValue=false)]
        public System.IO.Stream CoverFile { get; set; }

        /// <summary>
        /// Specifies the custom channel type which is used for channel grouping. The length is limited to 128 characters.&lt;br /&gt;&lt;br /&gt; Custom types are also used within Sendbird&#39;s [Advanced analytics](/docs/chat/v3/platform-api/guides/advanced-analytics) to segment metrics, which enables the sub-classification of data views.
        /// </summary>
        /// <value>Specifies the custom channel type which is used for channel grouping. The length is limited to 128 characters.&lt;br /&gt;&lt;br /&gt; Custom types are also used within Sendbird&#39;s [Advanced analytics](/docs/chat/v3/platform-api/guides/advanced-analytics) to segment metrics, which enables the sub-classification of data views.</value>
        [DataMember(Name="custom_type", EmitDefaultValue=false)]
        public string CustomType { get; set; }

        /// <summary>
        /// Specifies additional channel information such as a long description of the channel or &#x60;JSON&#x60; formatted string.
        /// </summary>
        /// <value>Specifies additional channel information such as a long description of the channel or &#x60;JSON&#x60; formatted string.</value>
        [DataMember(Name="data", EmitDefaultValue=false)]
        public string Data { get; set; }

        /// <summary>
        /// Determines whether to preserve the messages in the channel for the purpose of retrieving chat history or not. It set to true, the messages in the channel are not saved in the Sendbird database and the chat history can&#39;t be retrieved. (Default: false)
        /// </summary>
        /// <value>Determines whether to preserve the messages in the channel for the purpose of retrieving chat history or not. It set to true, the messages in the channel are not saved in the Sendbird database and the chat history can&#39;t be retrieved. (Default: false)</value>
        [DataMember(Name="is_ephemeral", EmitDefaultValue=false)]
        public bool IsEphemeral { get; set; }

        /// <summary>
        /// Determines whether the channel is an open channel with dynamic partitioning or not. If the value of this property is true, the open channel can create several subchannels in order to accommodate a massive number of usres. (Default: false)&lt;br/&gt;&lt;br/&gt;  For the new Sendbird applications created after December 15, 2020, this property will be automatically set to true.
        /// </summary>
        /// <value>Determines whether the channel is an open channel with dynamic partitioning or not. If the value of this property is true, the open channel can create several subchannels in order to accommodate a massive number of usres. (Default: false)&lt;br/&gt;&lt;br/&gt;  For the new Sendbird applications created after December 15, 2020, this property will be automatically set to true.</value>
        [DataMember(Name="[is_dynamic_partitioned](#2-how-dynamic-partitioning-works)", EmitDefaultValue=false)]
        public bool IsDynamicPartitioned2HowDynamicPartitioningWorks { get; set; }

        /// <summary>
        /// Specifies an array of one or more user IDs to register as operators of the channel. The maximum allowed number of operators per channel is 100. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.&lt;br/&gt;&lt;br/&gt;  Operators cannot view messages that have been [moderated by](/docs/chat/v3/platform-api/guides/filter-and-moderation) the domain filter or profanity filter. Only the sender will be notified that the message has been blocked.
        /// </summary>
        /// <value>Specifies an array of one or more user IDs to register as operators of the channel. The maximum allowed number of operators per channel is 100. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.&lt;br/&gt;&lt;br/&gt;  Operators cannot view messages that have been [moderated by](/docs/chat/v3/platform-api/guides/filter-and-moderation) the domain filter or profanity filter. Only the sender will be notified that the message has been blocked.</value>
        [DataMember(Name="operator_ids", EmitDefaultValue=false)]
        public List<string> OperatorIds { get; set; }

        /// <summary>
        /// (Deprecated) Specifies the string IDs of the users registered as channel operators. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.
        /// </summary>
        /// <value>(Deprecated) Specifies the string IDs of the users registered as channel operators. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.</value>
        [DataMember(Name="operators", EmitDefaultValue=false)]
        public List<string> Operators { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class OcCreateChannelData {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  ChannelUrl: ").Append(ChannelUrl).Append("\n");
            sb.Append("  CoverUrl: ").Append(CoverUrl).Append("\n");
            sb.Append("  CoverFile: ").Append(CoverFile).Append("\n");
            sb.Append("  CustomType: ").Append(CustomType).Append("\n");
            sb.Append("  Data: ").Append(Data).Append("\n");
            sb.Append("  IsEphemeral: ").Append(IsEphemeral).Append("\n");
            sb.Append("  IsDynamicPartitioned2HowDynamicPartitioningWorks: ").Append(IsDynamicPartitioned2HowDynamicPartitioningWorks).Append("\n");
            sb.Append("  OperatorIds: ").Append(OperatorIds).Append("\n");
            sb.Append("  Operators: ").Append(Operators).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OcCreateChannelData);
        }

        /// <summary>
        /// Returns true if OcCreateChannelData instances are equal
        /// </summary>
        /// <param name="input">Instance of OcCreateChannelData to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OcCreateChannelData input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.ChannelUrl == input.ChannelUrl ||
                    (this.ChannelUrl != null &&
                    this.ChannelUrl.Equals(input.ChannelUrl))
                ) && 
                (
                    this.CoverUrl == input.CoverUrl ||
                    (this.CoverUrl != null &&
                    this.CoverUrl.Equals(input.CoverUrl))
                ) && 
                (
                    this.CoverFile == input.CoverFile ||
                    (this.CoverFile != null &&
                    this.CoverFile.Equals(input.CoverFile))
                ) && 
                (
                    this.CustomType == input.CustomType ||
                    (this.CustomType != null &&
                    this.CustomType.Equals(input.CustomType))
                ) && 
                (
                    this.Data == input.Data ||
                    (this.Data != null &&
                    this.Data.Equals(input.Data))
                ) && 
                (
                    this.IsEphemeral == input.IsEphemeral ||
                    (this.IsEphemeral != null &&
                    this.IsEphemeral.Equals(input.IsEphemeral))
                ) && 
                (
                    this.IsDynamicPartitioned2HowDynamicPartitioningWorks == input.IsDynamicPartitioned2HowDynamicPartitioningWorks ||
                    (this.IsDynamicPartitioned2HowDynamicPartitioningWorks != null &&
                    this.IsDynamicPartitioned2HowDynamicPartitioningWorks.Equals(input.IsDynamicPartitioned2HowDynamicPartitioningWorks))
                ) && 
                (
                    this.OperatorIds == input.OperatorIds ||
                    this.OperatorIds != null &&
                    input.OperatorIds != null &&
                    this.OperatorIds.SequenceEqual(input.OperatorIds)
                ) && 
                (
                    this.Operators == input.Operators ||
                    this.Operators != null &&
                    input.Operators != null &&
                    this.Operators.SequenceEqual(input.Operators)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.ChannelUrl != null)
                    hashCode = hashCode * 59 + this.ChannelUrl.GetHashCode();
                if (this.CoverUrl != null)
                    hashCode = hashCode * 59 + this.CoverUrl.GetHashCode();
                if (this.CoverFile != null)
                    hashCode = hashCode * 59 + this.CoverFile.GetHashCode();
                if (this.CustomType != null)
                    hashCode = hashCode * 59 + this.CustomType.GetHashCode();
                if (this.Data != null)
                    hashCode = hashCode * 59 + this.Data.GetHashCode();
                if (this.IsEphemeral != null)
                    hashCode = hashCode * 59 + this.IsEphemeral.GetHashCode();
                if (this.IsDynamicPartitioned2HowDynamicPartitioningWorks != null)
                    hashCode = hashCode * 59 + this.IsDynamicPartitioned2HowDynamicPartitioningWorks.GetHashCode();
                if (this.OperatorIds != null)
                    hashCode = hashCode * 59 + this.OperatorIds.GetHashCode();
                if (this.Operators != null)
                    hashCode = hashCode * 59 + this.Operators.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
